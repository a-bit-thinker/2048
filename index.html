<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Keep Ask Why</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      padding: 16px;
      line-height: 1.4;
    }
    #status { white-space: pre-wrap; }
    #log { margin-top: 12px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <div id="status">Loading...</div>
  <div id="log"></div>

  <script>
    (function () {
      const DEFAULT_QUESTIONS = [
        "Why are you doing this?",
        "What is not working?",
        "Why did this fail?",
        "What are you avoiding?",
        "What matters most right now?",
        "What is the simplest next step?",
        "What are you assuming without proof?",
        "What are you afraid to admit?",
        "What did you learn from the last try?",
        "What can you remove?",
        "Are you solving the right problem?",
        "What if you are wrong?",
        "What are you repeating?",
        "What would make this easier?",
        "What would you do if you had to finish today?",
        "Why are you still stuck?",
        "What is the real goal?",
        "What are you postponing?",
        "What do you need to ask next?",
        "Why does this matter?"
      ];

      const statusEl = document.getElementById("status");
      const logEl = document.getElementById("log");
      const params = new URLSearchParams(location.search);
      const initialInterval = Math.max(1, Number(params.get("interval") || 200));

      const state = {
        questions: DEFAULT_QUESTIONS.slice(),
        intervalSec: initialInterval,
        index: 0,
        timer: null,
        running: false
      };

      function now() {
        return new Date().toISOString().replace("T", " ").replace("Z", "");
      }

      function renderStatus() {
        statusEl.textContent =
          "keep-ask-why active\n" +
          "interval_sec=" + state.intervalSec + "\n" +
          "question_count=" + state.questions.length + "\n" +
          "running=" + state.running + "\n" +
          "controls: keepAskWhy.status(), keepAskWhy.next(), keepAskWhy.ask('text'), keepAskWhy.askMarkdown('# title\\ntext'), keepAskWhy.request('POST','/ask',{markdown:'...'}), keepAskWhy.setIntervalSec(60), keepAskWhy.setQuestions([...]), keepAskWhy.start(), keepAskWhy.stop()";
      }

      function pushLine(line) {
        console.log(line);
        const next = logEl.textContent + line + "\n";
        const keepLast = next.split("\n").slice(-60).join("\n");
        logEl.textContent = keepLast;
      }

      function nextQuestion() {
        if (!state.questions.length) {
          return "Why?";
        }
        const q = state.questions[state.index];
        state.index = (state.index + 1) % state.questions.length;
        return q;
      }

      function askQuestion(text) {
        if (!text) {
          return nextQuestion();
        }
        let h = 0;
        for (let i = 0; i < text.length; i += 1) {
          h = ((h << 5) - h + text.charCodeAt(i)) | 0;
        }
        const idx = Math.abs(h) % state.questions.length;
        return state.questions[idx];
      }

      function normalizeAskText(payload) {
        if (payload == null) {
          return "";
        }
        if (typeof payload === "string") {
          return payload;
        }
        if (typeof payload === "object") {
          if (typeof payload.markdown === "string") {
            return payload.markdown;
          }
          if (typeof payload.text === "string") {
            return payload.text;
          }
        }
        return String(payload);
      }

      function decodeBase64Utf8(input) {
        try {
          const binary = atob(input);
          const bytes = Uint8Array.from(binary, function (c) { return c.charCodeAt(0); });
          return new TextDecoder().decode(bytes);
        } catch (_err) {
          return "";
        }
      }

      function tick() {
        const q = nextQuestion();
        pushLine("[" + now() + "] " + q);
        return q;
      }

      function restartTimer() {
        if (state.timer) {
          clearInterval(state.timer);
        }
        if (!state.running) {
          return;
        }
        state.timer = setInterval(tick, state.intervalSec * 1000);
      }

      const api = {
        health: function () {
          return {
            ok: true,
            running: state.running,
            interval_sec: state.intervalSec,
            question_count: state.questions.length
          };
        },
        next: function () {
          const q = tick();
          return { question: q };
        },
        ask: function (input) {
          const text = normalizeAskText(input);
          const q = askQuestion(text);
          pushLine("[" + now() + "] " + q);
          return { question: q, received_text: text };
        },
        askMarkdown: function (markdown) {
          return api.ask({ markdown: String(markdown || "") });
        },
        setIntervalSec: function (n) {
          const next = Math.max(1, Number(n || 1));
          state.intervalSec = next;
          renderStatus();
          restartTimer();
          return { interval_sec: state.intervalSec };
        },
        setQuestions: function (list) {
          if (!Array.isArray(list) || list.length === 0) {
            throw new Error("questions must be a non-empty array");
          }
          state.questions = list.map(function (x) {
            const s = String(x || "").trim();
            if (!s) {
              throw new Error("each question must be non-empty");
            }
            return s;
          });
          state.index = 0;
          renderStatus();
          return { count: state.questions.length };
        },
        start: function () {
          if (state.running) {
            return { running: true };
          }
          state.running = true;
          renderStatus();
          tick();
          restartTimer();
          return { running: true };
        },
        stop: function () {
          state.running = false;
          if (state.timer) {
            clearInterval(state.timer);
            state.timer = null;
          }
          renderStatus();
          return { running: false };
        },
        status: function () {
          return api.health();
        },
        request: function (method, path, body) {
          const m = String(method || "GET").toUpperCase();
          const p = String(path || "");
          if (m === "GET" && p === "/health") {
            return api.health();
          }
          if (m === "GET" && p === "/next") {
            return api.next();
          }
          if (m === "POST" && p === "/ask") {
            return api.ask(body || "");
          }
          if (m === "POST" && p === "/interval") {
            const value = body && body.interval_sec != null ? body.interval_sec : body && body.intervalSec;
            return api.setIntervalSec(value);
          }
          if (m === "POST" && p === "/questions") {
            const list = body && body.questions;
            return api.setQuestions(list);
          }
          throw new Error("not found: " + m + " " + p);
        }
      };

      window.keepAskWhy = api;
      renderStatus();
      api.start();

      const md = params.get("md");
      const mdB64 = params.get("md_b64");
      if (mdB64) {
        api.askMarkdown(decodeBase64Utf8(mdB64));
      } else if (md) {
        api.askMarkdown(md);
      }
    })();
  </script>
</body>
</html>
